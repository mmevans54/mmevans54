{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "9caf08f2",
   "metadata": {
    "papermill": {
     "duration": 0.016354,
     "end_time": "2024-06-03T04:37:53.990342",
     "exception": false,
     "start_time": "2024-06-03T04:37:53.973988",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# What to Do\n",
    "\n",
    "Make this entire notebook a professional quality artifact that is worth showing to an interviewer, colleague, or client. You may model your work after all of the previous notebooks we have seen in this course. Keep in mind that *you* are the author of this notebook, and that fellow professionals are the audience. As such, be sure to delete all text above this statement, such that your **Introduction** introduces us to the problem/goal that we will see in the notebook."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8173a0f7",
   "metadata": {
    "papermill": {
     "duration": 0.015627,
     "end_time": "2024-06-03T04:37:54.022195",
     "exception": false,
     "start_time": "2024-06-03T04:37:54.006568",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Introduction"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "08e627a4",
   "metadata": {
    "papermill": {
     "duration": 0.015797,
     "end_time": "2024-06-03T04:37:54.054395",
     "exception": false,
     "start_time": "2024-06-03T04:37:54.038598",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Notebook 9 aims to demonstrate proficiency in meeting course learning goals by applying an ML model to solve a classification problem using ML libraries. This includes describing and applying a ML workflow."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "34e36157",
   "metadata": {
    "papermill": {
     "duration": 0.015477,
     "end_time": "2024-06-03T04:37:54.085860",
     "exception": false,
     "start_time": "2024-06-03T04:37:54.070383",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Problem Statement"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7f5eff7d",
   "metadata": {
    "papermill": {
     "duration": 0.015798,
     "end_time": "2024-06-03T04:37:54.117496",
     "exception": false,
     "start_time": "2024-06-03T04:37:54.101698",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "This notebook provides a guide through **sentiment analysis** ML workflow, using a **Support Vector Machine (SVM)** (linear classifier) from the scikit-learn python library. First, we must work through a Machine Learning workflow to ensure our data is prepared for the analysis, ensuring we can relay on our model's results. Carefully assessing and processing these data results in accurate modeling and trustworthy applications."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "22d53172",
   "metadata": {
    "papermill": {
     "duration": 0.015463,
     "end_time": "2024-06-03T04:37:54.149293",
     "exception": false,
     "start_time": "2024-06-03T04:37:54.133830",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Step 1: Import Libraries"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "120a4c3b",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:37:54.183013Z",
     "iopub.status.busy": "2024-06-03T04:37:54.182595Z",
     "iopub.status.idle": "2024-06-03T04:37:55.555491Z",
     "shell.execute_reply": "2024-06-03T04:37:55.554297Z"
    },
    "papermill": {
     "duration": 1.393002,
     "end_time": "2024-06-03T04:37:55.558316",
     "exception": false,
     "start_time": "2024-06-03T04:37:54.165314",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/conda/lib/python3.10/site-packages/scipy/__init__.py:146: UserWarning: A NumPy version >=1.16.5 and <1.23.0 is required for this version of SciPy (detected version 1.23.5\n",
      "  warnings.warn(f\"A NumPy version >={np_minversion} and <{np_maxversion}\"\n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.feature_extraction.text import TfidfVectorizer\n",
    "from sklearn.feature_extraction.text import CountVectorizer\n",
    "from sklearn.metrics import classification_report\n",
    "from sklearn.svm import SVC\n",
    "from sklearn import svm"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3690c2e4",
   "metadata": {
    "papermill": {
     "duration": 0.016512,
     "end_time": "2024-06-03T04:37:55.591616",
     "exception": false,
     "start_time": "2024-06-03T04:37:55.575104",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Step 2: Load the Data"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b3bc8a93",
   "metadata": {
    "papermill": {
     "duration": 0.015663,
     "end_time": "2024-06-03T04:37:55.623388",
     "exception": false,
     "start_time": "2024-06-03T04:37:55.607725",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "This model is trained with the the **Sentiment Polarity Data Set v2.0** from [Movie Review Data](http://www.cs.cornell.edu/people/pabo/movie-review-data/) by Pang, Lee and Vaithyanathan. The complete training set and a test set have been provided, and hence the workflow for these steps are excluded from this notebook. Please refer to outside sources to better understand the steps used for data exploration, preprocessing, and preparing the test and training sets used in ML model applications.\n",
    "\n",
    "Kaggle's movie-review datasets are widely used in publication. They are labeled using their **sentiment polarity** (positive or negative) or **subjective rating** (how many stars the movie recieves). The text sentences are labeled with their **subjectivity status** (subjective or objective - i.e. polarity)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "2cbbe0f5",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:37:55.657174Z",
     "iopub.status.busy": "2024-06-03T04:37:55.656772Z",
     "iopub.status.idle": "2024-06-03T04:37:55.856431Z",
     "shell.execute_reply": "2024-06-03T04:37:55.855262Z"
    },
    "papermill": {
     "duration": 0.219801,
     "end_time": "2024-06-03T04:37:55.859145",
     "exception": false,
     "start_time": "2024-06-03T04:37:55.639344",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "reviews_training = pd.read_csv(\"/kaggle/input/movie-reviews-sentiment-polarity/movie_reviews_train.csv\")\n",
    "reviews_test = pd.read_csv(\"/kaggle/input/movie-reviews-sentiment-polarity/movie_reviews_test.csv\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a95c99ad",
   "metadata": {
    "papermill": {
     "duration": 0.015916,
     "end_time": "2024-06-03T04:37:55.891552",
     "exception": false,
     "start_time": "2024-06-03T04:37:55.875636",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Step 3: Explore the Data"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "754de9c8",
   "metadata": {
    "papermill": {
     "duration": 0.015737,
     "end_time": "2024-06-03T04:37:55.922976",
     "exception": false,
     "start_time": "2024-06-03T04:37:55.907239",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "We want to look at our data dimensions, feature count and understand the type of data in our data set. We can do this by observing the first 5 rows of these data."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "28160d20",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:37:55.958014Z",
     "iopub.status.busy": "2024-06-03T04:37:55.957577Z",
     "iopub.status.idle": "2024-06-03T04:37:56.002597Z",
     "shell.execute_reply": "2024-06-03T04:37:56.001498Z"
    },
    "papermill": {
     "duration": 0.066203,
     "end_time": "2024-06-03T04:37:56.005258",
     "exception": false,
     "start_time": "2024-06-03T04:37:55.939055",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>Content</th>\n",
       "      <th>Label</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>count</th>\n",
       "      <td>1800</td>\n",
       "      <td>1800</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>unique</th>\n",
       "      <td>1800</td>\n",
       "      <td>2</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>top</th>\n",
       "      <td>every once in a while you see a film that is s...</td>\n",
       "      <td>pos</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>freq</th>\n",
       "      <td>1</td>\n",
       "      <td>900</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "                                                  Content Label\n",
       "count                                                1800  1800\n",
       "unique                                               1800     2\n",
       "top     every once in a while you see a film that is s...   pos\n",
       "freq                                                    1   900"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "reviews_training.describe()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f1814cba",
   "metadata": {
    "papermill": {
     "duration": 0.016272,
     "end_time": "2024-06-03T04:37:56.037781",
     "exception": false,
     "start_time": "2024-06-03T04:37:56.021509",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "There is a count of 1800 values in the training data set. We have two columns, one named \"Content\" and the other named, \"Label\". We can note, at this point, we have text data for the Content (representing the review) and a Label determining the positive or negative sentiment of each review."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "fb387b07",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:37:56.072261Z",
     "iopub.status.busy": "2024-06-03T04:37:56.071210Z",
     "iopub.status.idle": "2024-06-03T04:37:56.085888Z",
     "shell.execute_reply": "2024-06-03T04:37:56.084863Z"
    },
    "papermill": {
     "duration": 0.034224,
     "end_time": "2024-06-03T04:37:56.088118",
     "exception": false,
     "start_time": "2024-06-03T04:37:56.053894",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>Content</th>\n",
       "      <th>Label</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>count</th>\n",
       "      <td>200</td>\n",
       "      <td>200</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>unique</th>\n",
       "      <td>200</td>\n",
       "      <td>2</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>top</th>\n",
       "      <td>hedwig ( john cameron mitchell ) was born a bo...</td>\n",
       "      <td>pos</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>freq</th>\n",
       "      <td>1</td>\n",
       "      <td>100</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "                                                  Content Label\n",
       "count                                                 200   200\n",
       "unique                                                200     2\n",
       "top     hedwig ( john cameron mitchell ) was born a bo...   pos\n",
       "freq                                                    1   100"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "reviews_test.describe()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "39a22253",
   "metadata": {
    "papermill": {
     "duration": 0.01602,
     "end_time": "2024-06-03T04:37:56.120565",
     "exception": false,
     "start_time": "2024-06-03T04:37:56.104545",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "There is a subset count of 200 values from the original data set, assigned to test these data."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "9f96cf78",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:37:56.154745Z",
     "iopub.status.busy": "2024-06-03T04:37:56.154326Z",
     "iopub.status.idle": "2024-06-03T04:37:56.164511Z",
     "shell.execute_reply": "2024-06-03T04:37:56.163428Z"
    },
    "papermill": {
     "duration": 0.029653,
     "end_time": "2024-06-03T04:37:56.166557",
     "exception": false,
     "start_time": "2024-06-03T04:37:56.136904",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>Content</th>\n",
       "      <th>Label</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>every once in a while you see a film that is s...</td>\n",
       "      <td>pos</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>the love for family is one of the strongest dr...</td>\n",
       "      <td>pos</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>after the terminally bleak reservoir dogs and ...</td>\n",
       "      <td>pos</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>( warning to those who have not seen seven : ...</td>\n",
       "      <td>pos</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>having not seen , \" who framed roger rabbit \" ...</td>\n",
       "      <td>pos</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "                                             Content Label\n",
       "0  every once in a while you see a film that is s...   pos\n",
       "1  the love for family is one of the strongest dr...   pos\n",
       "2  after the terminally bleak reservoir dogs and ...   pos\n",
       "3   ( warning to those who have not seen seven : ...   pos\n",
       "4  having not seen , \" who framed roger rabbit \" ...   pos"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "reviews_training.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ad1652a6",
   "metadata": {
    "papermill": {
     "duration": 0.016255,
     "end_time": "2024-06-03T04:37:56.199324",
     "exception": false,
     "start_time": "2024-06-03T04:37:56.183069",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Here, we see that \"pos\" and \"neg\" are the labels used to describe the prescribed sentiment. Our text data is large enough that we cannot manually assign numberic values (in later steps), so we can already determine we will be dependent on python's built in libraries that expidite the classficiation process."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "d8ff4150",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:37:56.233942Z",
     "iopub.status.busy": "2024-06-03T04:37:56.233511Z",
     "iopub.status.idle": "2024-06-03T04:37:56.244209Z",
     "shell.execute_reply": "2024-06-03T04:37:56.242906Z"
    },
    "papermill": {
     "duration": 0.031277,
     "end_time": "2024-06-03T04:37:56.246867",
     "exception": false,
     "start_time": "2024-06-03T04:37:56.215590",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>Content</th>\n",
       "      <th>Label</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>hedwig ( john cameron mitchell ) was born a bo...</td>\n",
       "      <td>pos</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>one of the more unusual and suggestively viole...</td>\n",
       "      <td>pos</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>what do you get when you combine clueless and ...</td>\n",
       "      <td>pos</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>&gt;from the man who presented us with henry : th...</td>\n",
       "      <td>pos</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>tibet has entered the american consciousness s...</td>\n",
       "      <td>pos</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "                                             Content Label\n",
       "0  hedwig ( john cameron mitchell ) was born a bo...   pos\n",
       "1  one of the more unusual and suggestively viole...   pos\n",
       "2  what do you get when you combine clueless and ...   pos\n",
       "3  >from the man who presented us with henry : th...   pos\n",
       "4  tibet has entered the american consciousness s...   pos"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "reviews_test.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5f62f70d",
   "metadata": {
    "papermill": {
     "duration": 0.017196,
     "end_time": "2024-06-03T04:37:56.281237",
     "exception": false,
     "start_time": "2024-06-03T04:37:56.264041",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "We can see that our data included text data - the reviews (to be expected)- and there are two columns, total. The label columns assigns the polarity (positive or negative reviews) for the movie, and the text column provides the original human text capturing the reviewer's opinion. We are ready to start pre-processing our data."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a05d10fe",
   "metadata": {
    "papermill": {
     "duration": 0.01735,
     "end_time": "2024-06-03T04:37:56.315496",
     "exception": false,
     "start_time": "2024-06-03T04:37:56.298146",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Step 4: Preprocessing "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3b787bbf",
   "metadata": {
    "papermill": {
     "duration": 0.016483,
     "end_time": "2024-06-03T04:37:56.349220",
     "exception": false,
     "start_time": "2024-06-03T04:37:56.332737",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Sentiment analysis problems often require raw data in the form of text - like we see with our movie review train and test data - which we will use to generate a a **corpus** (a collection of documents). Other examples include; Yelp reviews, google reviews, and air bnb reviews - all of which subtly express the nuances in human discord and preferences. \n",
    "\n",
    "Sentiment analysis is a classification task, meaning the preprocessing steps must include feature vectors segregated into a \"bag of words\", and assigned meaning (i.e. good or bad).\n",
    "\n",
    "Classifications for sentiment analysis commonly relay on \"normalized\" form of the frequencies, known as the **Term Frequency** - Inverse Document Frequency (TF-IDF). These applications are accessed in the sklearn library in python (as we see in our Notebook). In this step, we need to \"send our computer to school\" and \"teach it how to read\". Essentially, we are assigning classifiers to these data in order to generate a descrenable output in regards to predictive metrics. This is a basic step in Natural Language Processing (NLP) ML. Although we cannot witness the full extent of this classification process using the SkLearn package, I have included an example of a simplfied step-by-step coding process for the numeric classification assignments."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "79fcafbc",
   "metadata": {
    "papermill": {
     "duration": 0.016506,
     "end_time": "2024-06-03T04:37:56.382797",
     "exception": false,
     "start_time": "2024-06-03T04:37:56.366291",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "**Our first step is to transform our raw training data set into a useable, computationally translatable set of TF-IDF vectors.**\n",
    "\n",
    "TF-IDF vectors are an \"amenable\" approach to examine words of importance in text data. As mentioned, the SkLearn \"TfidfVectorizerLinks\" provides a simple API for transforming text into TF-IDF vectors. These vectors are immediately prepped for training. The TfidfVectorizer \"compresses\" the previously exemplified data matrix into a highly efficient internal format. \n",
    "\n",
    "This process includes internal columns representing features (possible words) and rows which are the TF-IDF vector, assigned a non-zero number - a conceptual breakdown of the process. However, the TfidfVectorizer does not display the optimization steps. We can't see every step occurring in the process, but we can implement check points to ensure our model is operational and optimizing using additional steps outlined in this Notebook. \n",
    "\n",
    "The end product for this step includes TF-IDF vectors, ready for training."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "b97cbf40",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:37:56.418910Z",
     "iopub.status.busy": "2024-06-03T04:37:56.418518Z",
     "iopub.status.idle": "2024-06-03T04:37:57.515761Z",
     "shell.execute_reply": "2024-06-03T04:37:57.514622Z"
    },
    "papermill": {
     "duration": 1.118263,
     "end_time": "2024-06-03T04:37:57.518539",
     "exception": false,
     "start_time": "2024-06-03T04:37:56.400276",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "vectorizer = TfidfVectorizer(min_df = 1, max_df = 1.0, sublinear_tf = True, use_idf = True)\n",
    "training_vectors = vectorizer.fit_transform(reviews_training['Content'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "57821749",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:37:57.554590Z",
     "iopub.status.busy": "2024-06-03T04:37:57.554084Z",
     "iopub.status.idle": "2024-06-03T04:37:57.561886Z",
     "shell.execute_reply": "2024-06-03T04:37:57.560513Z"
    },
    "papermill": {
     "duration": 0.028458,
     "end_time": "2024-06-03T04:37:57.564382",
     "exception": false,
     "start_time": "2024-06-03T04:37:57.535924",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(1800, 37987)"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "training_vectors.shape"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d19dcfdc",
   "metadata": {
    "papermill": {
     "duration": 0.017012,
     "end_time": "2024-06-03T04:37:57.598254",
     "exception": false,
     "start_time": "2024-06-03T04:37:57.581242",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "It appears all 1800 counts are included with the new number assignments."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ab90f3c0",
   "metadata": {
    "papermill": {
     "duration": 0.016397,
     "end_time": "2024-06-03T04:37:57.631374",
     "exception": false,
     "start_time": "2024-06-03T04:37:57.614977",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Now, lets' inspect our training set using a matrix showing the indices and features, ensurins the classification labels are now assigned a numeric value, and theTfidVectorizer function reduced our data to only words of special importance. This code chunk was used to examine the vocabulary, but I have commented it out because it takes up a lot of space and is not necessary for the official workflow of the analysis. Though, it is nice to use while exploring these data."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "c03b9dd5",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:37:57.667592Z",
     "iopub.status.busy": "2024-06-03T04:37:57.666603Z",
     "iopub.status.idle": "2024-06-03T04:37:57.671547Z",
     "shell.execute_reply": "2024-06-03T04:37:57.670536Z"
    },
    "papermill": {
     "duration": 0.025802,
     "end_time": "2024-06-03T04:37:57.673783",
     "exception": false,
     "start_time": "2024-06-03T04:37:57.647981",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "#non_zero_elements = training_vectors.nonzero()\n",
    "#rows = non_zero_elements[0]\n",
    "#cols = non_zero_elements[1]\n",
    "#values = training_vectors.data\n",
    "\n",
    "#non-zero elements\n",
    "#for row, col, value in zip(rows, cols, values):\n",
    "    #f\"({row}, {col})\\t{value}\"\n",
    "\n",
    "# features and indices\n",
    "#feature_names = vectorizer.vocabulary_\n",
    "#feature_names"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fe0bc598",
   "metadata": {
    "papermill": {
     "duration": 0.016518,
     "end_time": "2024-06-03T04:37:57.707259",
     "exception": false,
     "start_time": "2024-06-03T04:37:57.690741",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "It looks good!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "dd632a3a",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:37:57.743217Z",
     "iopub.status.busy": "2024-06-03T04:37:57.742804Z",
     "iopub.status.idle": "2024-06-03T04:37:57.750206Z",
     "shell.execute_reply": "2024-06-03T04:37:57.749145Z"
    },
    "papermill": {
     "duration": 0.028414,
     "end_time": "2024-06-03T04:37:57.752492",
     "exception": false,
     "start_time": "2024-06-03T04:37:57.724078",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(1800, 37987)"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "training_vectors.shape # n samples, n features"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b30cab14",
   "metadata": {
    "papermill": {
     "duration": 0.016614,
     "end_time": "2024-06-03T04:37:57.785986",
     "exception": false,
     "start_time": "2024-06-03T04:37:57.769372",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "I'm checking the shape of the output file. It appears we have 4 samples total, and 9 features left after creating our TF-IDF vectors."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "470d1930",
   "metadata": {
    "papermill": {
     "duration": 0.016858,
     "end_time": "2024-06-03T04:37:57.819608",
     "exception": false,
     "start_time": "2024-06-03T04:37:57.802750",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## ***If we break this down simply, set-by-step, opposed to relaying on python's sklearn library, this is essentially how we are assigning the numeric values to each word in the content or review.***"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "216accb2",
   "metadata": {
    "papermill": {
     "duration": 0.01669,
     "end_time": "2024-06-03T04:37:57.852959",
     "exception": false,
     "start_time": "2024-06-03T04:37:57.836269",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "##  A Simplified Example"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d0f089ca",
   "metadata": {
    "papermill": {
     "duration": 0.01807,
     "end_time": "2024-06-03T04:37:57.891195",
     "exception": false,
     "start_time": "2024-06-03T04:37:57.873125",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "### Corpus \"Bag of Words\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "3defd814",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:37:57.927990Z",
     "iopub.status.busy": "2024-06-03T04:37:57.927613Z",
     "iopub.status.idle": "2024-06-03T04:37:57.932800Z",
     "shell.execute_reply": "2024-06-03T04:37:57.931500Z"
    },
    "papermill": {
     "duration": 0.02721,
     "end_time": "2024-06-03T04:37:57.935246",
     "exception": false,
     "start_time": "2024-06-03T04:37:57.908036",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "docA = \"I like learning Machine Learning\"\n",
    "docB = \"I don't think I am great at it, but it is still fun\""
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f7d60818",
   "metadata": {
    "papermill": {
     "duration": 0.019242,
     "end_time": "2024-06-03T04:37:57.971892",
     "exception": false,
     "start_time": "2024-06-03T04:37:57.952650",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "### Tokenizing"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "59f40818",
   "metadata": {
    "papermill": {
     "duration": 0.021973,
     "end_time": "2024-06-03T04:37:58.013872",
     "exception": false,
     "start_time": "2024-06-03T04:37:57.991899",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Tokenizing is when the corpus's \"bag of words\" is split into each individual word, allowing the computer to later determine individual words in their assigned classifier, and prescribe \"good\" or \"bad\" review predictions based on the origin of the singular word's classifier."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "3ad1647a",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:37:58.059086Z",
     "iopub.status.busy": "2024-06-03T04:37:58.058721Z",
     "iopub.status.idle": "2024-06-03T04:37:58.063821Z",
     "shell.execute_reply": "2024-06-03T04:37:58.062744Z"
    },
    "papermill": {
     "duration": 0.030124,
     "end_time": "2024-06-03T04:37:58.066162",
     "exception": false,
     "start_time": "2024-06-03T04:37:58.036038",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "bowA = docA.split()\n",
    "bowB = docB.split()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "e3a3095e",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:37:58.102018Z",
     "iopub.status.busy": "2024-06-03T04:37:58.101608Z",
     "iopub.status.idle": "2024-06-03T04:37:58.108623Z",
     "shell.execute_reply": "2024-06-03T04:37:58.107647Z"
    },
    "papermill": {
     "duration": 0.027429,
     "end_time": "2024-06-03T04:37:58.110761",
     "exception": false,
     "start_time": "2024-06-03T04:37:58.083332",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['I', 'like', 'learning', 'Machine', 'Learning']"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "bowA"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d19d802a",
   "metadata": {
    "papermill": {
     "duration": 0.017334,
     "end_time": "2024-06-03T04:37:58.145296",
     "exception": false,
     "start_time": "2024-06-03T04:37:58.127962",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "### Creating a Vector for \"Possible Words\" in each Bag of Words"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "184d5fac",
   "metadata": {
    "papermill": {
     "duration": 0.016624,
     "end_time": "2024-06-03T04:37:58.178987",
     "exception": false,
     "start_time": "2024-06-03T04:37:58.162363",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "When we create a vector for the tolkenized bag of words, we are able to turn these words into number assignments."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "9c618141",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:37:58.214622Z",
     "iopub.status.busy": "2024-06-03T04:37:58.214191Z",
     "iopub.status.idle": "2024-06-03T04:37:58.219588Z",
     "shell.execute_reply": "2024-06-03T04:37:58.218236Z"
    },
    "papermill": {
     "duration": 0.025936,
     "end_time": "2024-06-03T04:37:58.221897",
     "exception": false,
     "start_time": "2024-06-03T04:37:58.195961",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "wordSet= set(bowA).union(set(bowB))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "098af389",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:37:58.259953Z",
     "iopub.status.busy": "2024-06-03T04:37:58.259566Z",
     "iopub.status.idle": "2024-06-03T04:37:58.267554Z",
     "shell.execute_reply": "2024-06-03T04:37:58.266303Z"
    },
    "papermill": {
     "duration": 0.028743,
     "end_time": "2024-06-03T04:37:58.269929",
     "exception": false,
     "start_time": "2024-06-03T04:37:58.241186",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'I',\n",
       " 'Learning',\n",
       " 'Machine',\n",
       " 'am',\n",
       " 'at',\n",
       " 'but',\n",
       " \"don't\",\n",
       " 'fun',\n",
       " 'great',\n",
       " 'is',\n",
       " 'it',\n",
       " 'it,',\n",
       " 'learning',\n",
       " 'like',\n",
       " 'still',\n",
       " 'think'}"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#all words in all bags/documents\n",
    "wordSet"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7f299523",
   "metadata": {
    "papermill": {
     "duration": 0.017457,
     "end_time": "2024-06-03T04:37:58.304728",
     "exception": false,
     "start_time": "2024-06-03T04:37:58.287271",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Next, I want to create a dictionary to maintain the word counts."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "967c6b3e",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:37:58.341532Z",
     "iopub.status.busy": "2024-06-03T04:37:58.341111Z",
     "iopub.status.idle": "2024-06-03T04:37:58.346577Z",
     "shell.execute_reply": "2024-06-03T04:37:58.345498Z"
    },
    "papermill": {
     "duration": 0.026567,
     "end_time": "2024-06-03T04:37:58.348818",
     "exception": false,
     "start_time": "2024-06-03T04:37:58.322251",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "wordDictA = dict.fromkeys(wordSet, 0)\n",
    "wordDictB= dict.fromkeys(wordSet, 0)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "30b17b7f",
   "metadata": {
    "papermill": {
     "duration": 0.016909,
     "end_time": "2024-06-03T04:37:58.383133",
     "exception": false,
     "start_time": "2024-06-03T04:37:58.366224",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "I want to glimpse at these to make sure parsing is effective, and each \"bag of words\" word has an assigned a classifcation number."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "7159d0be",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:37:58.419345Z",
     "iopub.status.busy": "2024-06-03T04:37:58.418953Z",
     "iopub.status.idle": "2024-06-03T04:37:58.426079Z",
     "shell.execute_reply": "2024-06-03T04:37:58.424958Z"
    },
    "papermill": {
     "duration": 0.027995,
     "end_time": "2024-06-03T04:37:58.428512",
     "exception": false,
     "start_time": "2024-06-03T04:37:58.400517",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'like': 0,\n",
       " 'still': 0,\n",
       " 'am': 0,\n",
       " 'great': 0,\n",
       " 'I': 0,\n",
       " 'Machine': 0,\n",
       " 'at': 0,\n",
       " 'but': 0,\n",
       " 'Learning': 0,\n",
       " 'it,': 0,\n",
       " 'it': 0,\n",
       " \"don't\": 0,\n",
       " 'think': 0,\n",
       " 'is': 0,\n",
       " 'learning': 0,\n",
       " 'fun': 0}"
      ]
     },
     "execution_count": 17,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#taking a look\n",
    "wordDictA"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "4a086915",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:37:58.467267Z",
     "iopub.status.busy": "2024-06-03T04:37:58.466461Z",
     "iopub.status.idle": "2024-06-03T04:37:58.473647Z",
     "shell.execute_reply": "2024-06-03T04:37:58.472562Z"
    },
    "papermill": {
     "duration": 0.029871,
     "end_time": "2024-06-03T04:37:58.475993",
     "exception": false,
     "start_time": "2024-06-03T04:37:58.446122",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'like': 0,\n",
       " 'still': 0,\n",
       " 'am': 0,\n",
       " 'great': 0,\n",
       " 'I': 0,\n",
       " 'Machine': 0,\n",
       " 'at': 0,\n",
       " 'but': 0,\n",
       " 'Learning': 0,\n",
       " 'it,': 0,\n",
       " 'it': 0,\n",
       " \"don't\": 0,\n",
       " 'think': 0,\n",
       " 'is': 0,\n",
       " 'learning': 0,\n",
       " 'fun': 0}"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#taking a look\n",
    "wordDictB"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a0a3e083",
   "metadata": {
    "papermill": {
     "duration": 0.017322,
     "end_time": "2024-06-03T04:37:58.510941",
     "exception": false,
     "start_time": "2024-06-03T04:37:58.493619",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "We want to count the words in the bags, because understanding size is advantageous for later training our SVM (linear classifier)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "d6018ce1",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:37:58.547363Z",
     "iopub.status.busy": "2024-06-03T04:37:58.546968Z",
     "iopub.status.idle": "2024-06-03T04:37:58.552368Z",
     "shell.execute_reply": "2024-06-03T04:37:58.551239Z"
    },
    "papermill": {
     "duration": 0.026234,
     "end_time": "2024-06-03T04:37:58.554668",
     "exception": false,
     "start_time": "2024-06-03T04:37:58.528434",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "#counting each word in the bags\n",
    "for word in bowA:\n",
    "    wordDictA[word] +=1\n",
    "    \n",
    "for word in bowB:\n",
    "    wordDictB[word] +=1"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "286c965f",
   "metadata": {
    "papermill": {
     "duration": 0.01739,
     "end_time": "2024-06-03T04:37:58.590830",
     "exception": false,
     "start_time": "2024-06-03T04:37:58.573440",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Our last step is using a matrix, this enables us to view our word and number classifiers, easily. This turns a word problem, and generates a linear algebra problem, instead. This is far better for computer comprehension. However, it is critical to note that this strategy leaves our analysis vulnerable to including counts of words that simply do not contain a lot of information, becuase the approach includes all possible words from the movie review. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "c752880b",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:37:58.628886Z",
     "iopub.status.busy": "2024-06-03T04:37:58.628445Z",
     "iopub.status.idle": "2024-06-03T04:37:58.643458Z",
     "shell.execute_reply": "2024-06-03T04:37:58.642452Z"
    },
    "papermill": {
     "duration": 0.036267,
     "end_time": "2024-06-03T04:37:58.645759",
     "exception": false,
     "start_time": "2024-06-03T04:37:58.609492",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>like</th>\n",
       "      <th>still</th>\n",
       "      <th>am</th>\n",
       "      <th>great</th>\n",
       "      <th>I</th>\n",
       "      <th>Machine</th>\n",
       "      <th>at</th>\n",
       "      <th>but</th>\n",
       "      <th>Learning</th>\n",
       "      <th>it,</th>\n",
       "      <th>it</th>\n",
       "      <th>don't</th>\n",
       "      <th>think</th>\n",
       "      <th>is</th>\n",
       "      <th>learning</th>\n",
       "      <th>fun</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>0</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>2</td>\n",
       "      <td>0</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>1</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "   like  still  am  great  I  Machine  at  but  Learning  it,  it  don't  \\\n",
       "0     1      0   0      0  1        1   0    0         1    0   0      0   \n",
       "1     0      1   1      1  2        0   1    1         0    1   1      1   \n",
       "\n",
       "   think  is  learning  fun  \n",
       "0      0   0         1    0  \n",
       "1      1   1         0    1  "
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#matrix time\n",
    "pd.DataFrame([wordDictA, wordDictB])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0ea4bb00",
   "metadata": {
    "papermill": {
     "duration": 0.017389,
     "end_time": "2024-06-03T04:37:58.680772",
     "exception": false,
     "start_time": "2024-06-03T04:37:58.663383",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "*The above code is a simplified break down of the steps required for assigning numeric values to each bag of words - helping us better conceptualize the process behind the simplfied code lines.*\n",
    "\n",
    "It's important to understand method comparisions, and why the **TF-IDF** strategy is supervior. TF-IDF eliminates the common words in English - those words frequently do not enhance our understanding of the underlying polarity in the review message. Using the Power Law Distribution (the distribution of words). So, instead of just \"counting\" all of the words - we want to use the TF-IDF score of a word: tf(w)*idf(w)\n",
    "\n",
    "where **tf(w) = (Number of times the word appears in a document) / (Total number of words in the document)**\n",
    "and where **idf(w) = log(Number of documents /Number of documents that contain word w)**\n",
    "\n",
    "*Of course, there is a step-by-step breakdown for the application of TF-IDF, but for time's sake, we jumped straight into using python's SkLearn operative functions to work through the rest of our analysis.*\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "727f556b",
   "metadata": {
    "papermill": {
     "duration": 0.017488,
     "end_time": "2024-06-03T04:37:58.715827",
     "exception": false,
     "start_time": "2024-06-03T04:37:58.698339",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Step 5: Applying a SVM (linear classifier)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5d7a709c",
   "metadata": {
    "papermill": {
     "duration": 0.017395,
     "end_time": "2024-06-03T04:37:58.750753",
     "exception": false,
     "start_time": "2024-06-03T04:37:58.733358",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "The SkLearn fit methods we apply to our new classifiers accept efficient internal forms generating our ultimate training data. TfidfVectorizer performs the majority of the baseline effort, transforming the corpus of text data into TF-IDF vectors. These resulting TF-IDF vectors are immediately prepped for training."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "2915ed40",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:37:58.788273Z",
     "iopub.status.busy": "2024-06-03T04:37:58.787888Z",
     "iopub.status.idle": "2024-06-03T04:38:10.828425Z",
     "shell.execute_reply": "2024-06-03T04:38:10.827215Z"
    },
    "papermill": {
     "duration": 12.062591,
     "end_time": "2024-06-03T04:38:10.830940",
     "exception": false,
     "start_time": "2024-06-03T04:37:58.768349",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<style>#sk-container-id-1 {color: black;background-color: white;}#sk-container-id-1 pre{padding: 0;}#sk-container-id-1 div.sk-toggleable {background-color: white;}#sk-container-id-1 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-1 label.sk-toggleable__label-arrow:before {content: \"▸\";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-1 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-1 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-1 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-1 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-1 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-1 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: \"▾\";}#sk-container-id-1 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-1 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-1 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-1 div.sk-parallel-item::after {content: \"\";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-1 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-serial::before {content: \"\";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-1 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-1 div.sk-item {position: relative;z-index: 1;}#sk-container-id-1 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-1 div.sk-item::before, #sk-container-id-1 div.sk-parallel-item::before {content: \"\";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-1 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-1 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-1 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-1 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-1 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-1 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-1 div.sk-label-container {text-align: center;}#sk-container-id-1 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-1 div.sk-text-repr-fallback {display: none;}</style><div id=\"sk-container-id-1\" class=\"sk-top-container\"><div class=\"sk-text-repr-fallback\"><pre>SVC()</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class=\"sk-container\" hidden><div class=\"sk-item\"><div class=\"sk-estimator sk-toggleable\"><input class=\"sk-toggleable__control sk-hidden--visually\" id=\"sk-estimator-id-1\" type=\"checkbox\" checked><label for=\"sk-estimator-id-1\" class=\"sk-toggleable__label sk-toggleable__label-arrow\">SVC</label><div class=\"sk-toggleable__content\"><pre>SVC()</pre></div></div></div></div></div>"
      ],
      "text/plain": [
       "SVC()"
      ]
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "classifier = svm.SVC()\n",
    "classifier.fit(training_vectors, reviews_training['Label'])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a96a36f1",
   "metadata": {
    "papermill": {
     "duration": 0.017826,
     "end_time": "2024-06-03T04:38:10.867008",
     "exception": false,
     "start_time": "2024-06-03T04:38:10.849182",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Let's **instantiate** our new SVC, knowing it is automated with a default SkLearn SVM hyperparameters. We immediately recognize that the default hyperparameters may require adjustments to fit our specific data, which can be addressed after model validation. We're creating the training vectors using the assigned sentiment \"Labels\" from our movie review dataset."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "68b7330e",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:38:10.905746Z",
     "iopub.status.busy": "2024-06-03T04:38:10.905022Z",
     "iopub.status.idle": "2024-06-03T04:38:11.980812Z",
     "shell.execute_reply": "2024-06-03T04:38:11.979567Z"
    },
    "papermill": {
     "duration": 1.098563,
     "end_time": "2024-06-03T04:38:11.983616",
     "exception": false,
     "start_time": "2024-06-03T04:38:10.885053",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "vectorizer = TfidfVectorizer(min_df = 1, max_df = 1.0, sublinear_tf = True, use_idf = True)\n",
    "training_vectors = vectorizer.fit_transform(reviews_training['Content'])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "33fe23be",
   "metadata": {
    "papermill": {
     "duration": 0.019251,
     "end_time": "2024-06-03T04:38:12.021635",
     "exception": false,
     "start_time": "2024-06-03T04:38:12.002384",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Great! We have our default SVM applied to our transformed data."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "48c47f56",
   "metadata": {
    "papermill": {
     "duration": 0.017916,
     "end_time": "2024-06-03T04:38:12.058814",
     "exception": false,
     "start_time": "2024-06-03T04:38:12.040898",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "For **Step 5**, we instantiated a default SVM, and trained it with our training vectors and the polarized \"labels\". This was trained using the original training set. To validate our SVM, we need to examine the accuracy score output. But, it is advantegous to validate using a complete test set, particularly because we have corpus \"reviews_test\" data containing *Content* (i.e. Reviews) and *Labels* (i.e. sentiment). \n",
    "\n",
    "We need to transform our reviews_test data into TF-IDF vectors."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "3a4ab852",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:38:12.097092Z",
     "iopub.status.busy": "2024-06-03T04:38:12.096725Z",
     "iopub.status.idle": "2024-06-03T04:38:12.219214Z",
     "shell.execute_reply": "2024-06-03T04:38:12.217942Z"
    },
    "papermill": {
     "duration": 0.144603,
     "end_time": "2024-06-03T04:38:12.221920",
     "exception": false,
     "start_time": "2024-06-03T04:38:12.077317",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "test_vectors = vectorizer.transform(reviews_test['Content'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "c90500d0",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:38:12.261091Z",
     "iopub.status.busy": "2024-06-03T04:38:12.260693Z",
     "iopub.status.idle": "2024-06-03T04:38:12.408385Z",
     "shell.execute_reply": "2024-06-03T04:38:12.407279Z"
    },
    "papermill": {
     "duration": 0.17065,
     "end_time": "2024-06-03T04:38:12.411100",
     "exception": false,
     "start_time": "2024-06-03T04:38:12.240450",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "vectorizer = TfidfVectorizer(min_df = 1, max_df = 1.0, sublinear_tf = True, use_idf = True)\n",
    "testing_vectors = vectorizer.fit_transform(reviews_test['Content'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "3f53c521",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:38:12.449035Z",
     "iopub.status.busy": "2024-06-03T04:38:12.448649Z",
     "iopub.status.idle": "2024-06-03T04:38:12.455586Z",
     "shell.execute_reply": "2024-06-03T04:38:12.454459Z"
    },
    "papermill": {
     "duration": 0.028717,
     "end_time": "2024-06-03T04:38:12.457801",
     "exception": false,
     "start_time": "2024-06-03T04:38:12.429084",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(200, 13872)"
      ]
     },
     "execution_count": 25,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "testing_vectors.shape"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "15744ad5",
   "metadata": {
    "papermill": {
     "duration": 0.017979,
     "end_time": "2024-06-03T04:38:12.494132",
     "exception": false,
     "start_time": "2024-06-03T04:38:12.476153",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Done! As expected, our test data is smaller and comprised of (200,13872) dimensions, compared to our training data that reported (1800, 37987)."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1bdfc456",
   "metadata": {
    "papermill": {
     "duration": 0.017917,
     "end_time": "2024-06-03T04:38:12.530866",
     "exception": false,
     "start_time": "2024-06-03T04:38:12.512949",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Now, let's attempt to apply the same SVM model to the test data."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "c88d1f7a",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:38:12.570273Z",
     "iopub.status.busy": "2024-06-03T04:38:12.569847Z",
     "iopub.status.idle": "2024-06-03T04:38:12.731139Z",
     "shell.execute_reply": "2024-06-03T04:38:12.729998Z"
    },
    "papermill": {
     "duration": 0.184094,
     "end_time": "2024-06-03T04:38:12.733735",
     "exception": false,
     "start_time": "2024-06-03T04:38:12.549641",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<style>#sk-container-id-2 {color: black;background-color: white;}#sk-container-id-2 pre{padding: 0;}#sk-container-id-2 div.sk-toggleable {background-color: white;}#sk-container-id-2 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-2 label.sk-toggleable__label-arrow:before {content: \"▸\";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-2 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-2 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-2 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-2 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-2 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-2 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: \"▾\";}#sk-container-id-2 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-2 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-2 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-2 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-2 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-2 div.sk-parallel-item::after {content: \"\";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-2 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-2 div.sk-serial::before {content: \"\";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-2 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-2 div.sk-item {position: relative;z-index: 1;}#sk-container-id-2 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-2 div.sk-item::before, #sk-container-id-2 div.sk-parallel-item::before {content: \"\";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-2 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-2 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-2 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-2 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-2 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-2 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-2 div.sk-label-container {text-align: center;}#sk-container-id-2 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-2 div.sk-text-repr-fallback {display: none;}</style><div id=\"sk-container-id-2\" class=\"sk-top-container\"><div class=\"sk-text-repr-fallback\"><pre>SVC()</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class=\"sk-container\" hidden><div class=\"sk-item\"><div class=\"sk-estimator sk-toggleable\"><input class=\"sk-toggleable__control sk-hidden--visually\" id=\"sk-estimator-id-2\" type=\"checkbox\" checked><label for=\"sk-estimator-id-2\" class=\"sk-toggleable__label sk-toggleable__label-arrow\">SVC</label><div class=\"sk-toggleable__content\"><pre>SVC()</pre></div></div></div></div></div>"
      ],
      "text/plain": [
       "SVC()"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "classifier = svm.SVC()\n",
    "classifier.fit(testing_vectors, reviews_test['Label'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "c649480e",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:38:12.774550Z",
     "iopub.status.busy": "2024-06-03T04:38:12.773214Z",
     "iopub.status.idle": "2024-06-03T04:38:12.916119Z",
     "shell.execute_reply": "2024-06-03T04:38:12.914954Z"
    },
    "papermill": {
     "duration": 0.166361,
     "end_time": "2024-06-03T04:38:12.918813",
     "exception": false,
     "start_time": "2024-06-03T04:38:12.752452",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "vectorizer = TfidfVectorizer(min_df = 1, max_df = 1.0, sublinear_tf = True, use_idf = True)\n",
    "testing_vectors = vectorizer.fit_transform(reviews_test['Content'])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2106cab3",
   "metadata": {
    "papermill": {
     "duration": 0.018097,
     "end_time": "2024-06-03T04:38:12.955171",
     "exception": false,
     "start_time": "2024-06-03T04:38:12.937074",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Now that we have our test data in the SVM linear classifier, let us explore predictive outcomes with the default settings."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bc0da46a",
   "metadata": {
    "papermill": {
     "duration": 0.018186,
     "end_time": "2024-06-03T04:38:12.991750",
     "exception": false,
     "start_time": "2024-06-03T04:38:12.973564",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Step 6: Inital Predictions"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "93fb8583",
   "metadata": {
    "papermill": {
     "duration": 0.020454,
     "end_time": "2024-06-03T04:38:13.030755",
     "exception": false,
     "start_time": "2024-06-03T04:38:13.010301",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Let's have fun (work can be fun) and create predictions with our default SVM. I am anticipating the hyperparameters will require adjustments, but let's explore outputs before changing anything. We start with generating a collection of predictied sentiment labels."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "3eed2bcf",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:38:13.069444Z",
     "iopub.status.busy": "2024-06-03T04:38:13.068996Z",
     "iopub.status.idle": "2024-06-03T04:38:13.238175Z",
     "shell.execute_reply": "2024-06-03T04:38:13.236970Z"
    },
    "papermill": {
     "duration": 0.191859,
     "end_time": "2024-06-03T04:38:13.241027",
     "exception": false,
     "start_time": "2024-06-03T04:38:13.049168",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "predictions = classifier.predict(testing_vectors)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "82aff37e",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:38:13.280445Z",
     "iopub.status.busy": "2024-06-03T04:38:13.279342Z",
     "iopub.status.idle": "2024-06-03T04:38:13.286740Z",
     "shell.execute_reply": "2024-06-03T04:38:13.285739Z"
    },
    "papermill": {
     "duration": 0.029377,
     "end_time": "2024-06-03T04:38:13.288902",
     "exception": false,
     "start_time": "2024-06-03T04:38:13.259525",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array(['pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos',\n",
       "       'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos',\n",
       "       'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos',\n",
       "       'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos',\n",
       "       'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos',\n",
       "       'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos',\n",
       "       'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos',\n",
       "       'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos',\n",
       "       'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos',\n",
       "       'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos',\n",
       "       'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos',\n",
       "       'pos', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg',\n",
       "       'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg',\n",
       "       'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg',\n",
       "       'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg',\n",
       "       'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg',\n",
       "       'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg',\n",
       "       'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg',\n",
       "       'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg',\n",
       "       'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg',\n",
       "       'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg',\n",
       "       'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg',\n",
       "       'neg', 'neg'], dtype=object)"
      ]
     },
     "execution_count": 29,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "predictions"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ee06967e",
   "metadata": {
    "papermill": {
     "duration": 0.018169,
     "end_time": "2024-06-03T04:38:13.326097",
     "exception": false,
     "start_time": "2024-06-03T04:38:13.307928",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Check this out, boss! The SVM appears to be generating predictions for the sentiment labels effectively (postiive and negative review sentiment - i.e. assigned polarity)."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "eae9a12a",
   "metadata": {
    "papermill": {
     "duration": 0.019206,
     "end_time": "2024-06-03T04:38:13.363989",
     "exception": false,
     "start_time": "2024-06-03T04:38:13.344783",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Step 7: Model Validation"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e7b24725",
   "metadata": {
    "papermill": {
     "duration": 0.018465,
     "end_time": "2024-06-03T04:38:13.401266",
     "exception": false,
     "start_time": "2024-06-03T04:38:13.382801",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Now, let's check a summary of our results, including the **precision**, **recall**, and **f1-score** - this will guide our model tuning and adjustments for optimization."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "id": "229fa377",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:38:13.440835Z",
     "iopub.status.busy": "2024-06-03T04:38:13.440341Z",
     "iopub.status.idle": "2024-06-03T04:38:13.467205Z",
     "shell.execute_reply": "2024-06-03T04:38:13.466010Z"
    },
    "papermill": {
     "duration": 0.049545,
     "end_time": "2024-06-03T04:38:13.469498",
     "exception": false,
     "start_time": "2024-06-03T04:38:13.419953",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Positives:  {'precision': 1.0, 'recall': 1.0, 'f1-score': 1.0, 'support': 100}\n",
      "Negatives:  {'precision': 1.0, 'recall': 1.0, 'f1-score': 1.0, 'support': 100}\n"
     ]
    }
   ],
   "source": [
    "report = classification_report(reviews_test['Label'], predictions, output_dict=True)\n",
    "print('Positives: ', report['pos'])\n",
    "print('Negatives: ', report['neg'])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b2c85fa7",
   "metadata": {
    "papermill": {
     "duration": 0.018726,
     "end_time": "2024-06-03T04:38:13.506878",
     "exception": false,
     "start_time": "2024-06-03T04:38:13.488152",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "When it comes to interpretation of our results, we know that *precision* measures the accuracy of positive predictions (ratio of true postive predcitive to the total positive predictions), *recall* measures the ability of the classifier to ID all positive instances (ratio of true positive over the total actual positives), *f1-score* is the mean of precision and recall, and the *support* value is indicative of number of actual occurances of the positive class in test data.\n",
    "\n",
    "All that is to say, our model is performing exceptionally well. This is exemplfied for the classifications (\"pos\" and \"neg\"), and output suggesting **perfect** precision, recall, and F1-score (value of 1.0), with support of 100."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "baa95212",
   "metadata": {
    "papermill": {
     "duration": 0.018869,
     "end_time": "2024-06-03T04:38:13.544558",
     "exception": false,
     "start_time": "2024-06-03T04:38:13.525689",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Step 8: Model Tuning and Adjustments"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cbd96075",
   "metadata": {
    "papermill": {
     "duration": 0.01845,
     "end_time": "2024-06-03T04:38:13.581987",
     "exception": false,
     "start_time": "2024-06-03T04:38:13.563537",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Although our inital model totally hits the ball out-of-the-park with it's precision, recall, f1-score and support (although I am skeptical that something is wrong, given the perfect output on our default try), I still want to experiment with tuning and adjusting the model. I start with changing the max_df to 3, because this value helps eliminate words that have low frequency. This is a great hyperparameter to tune, because it can help eliminate words that are not frequently used."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "id": "a2a68fe0",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:38:13.622554Z",
     "iopub.status.busy": "2024-06-03T04:38:13.622116Z",
     "iopub.status.idle": "2024-06-03T04:38:14.682300Z",
     "shell.execute_reply": "2024-06-03T04:38:14.681179Z"
    },
    "papermill": {
     "duration": 1.08367,
     "end_time": "2024-06-03T04:38:14.685040",
     "exception": false,
     "start_time": "2024-06-03T04:38:13.601370",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "#training set\n",
    "vectorizer_experiment = TfidfVectorizer(min_df=3, max_df=1.0, sublinear_tf=True, use_idf=True)\n",
    "training_vectors_experiment = vectorizer.fit_transform(reviews_training['Content'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "id": "e682056a",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:38:14.724907Z",
     "iopub.status.busy": "2024-06-03T04:38:14.724505Z",
     "iopub.status.idle": "2024-06-03T04:38:14.853189Z",
     "shell.execute_reply": "2024-06-03T04:38:14.851801Z"
    },
    "papermill": {
     "duration": 0.152065,
     "end_time": "2024-06-03T04:38:14.855932",
     "exception": false,
     "start_time": "2024-06-03T04:38:14.703867",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "#test set\n",
    "testing_vectors_experiment = vectorizer_experiment.fit_transform(reviews_test['Content'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "id": "ff7a9f86",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:38:14.895654Z",
     "iopub.status.busy": "2024-06-03T04:38:14.894835Z",
     "iopub.status.idle": "2024-06-03T04:38:15.030571Z",
     "shell.execute_reply": "2024-06-03T04:38:15.029215Z"
    },
    "papermill": {
     "duration": 0.159482,
     "end_time": "2024-06-03T04:38:15.034442",
     "exception": false,
     "start_time": "2024-06-03T04:38:14.874960",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<style>#sk-container-id-3 {color: black;background-color: white;}#sk-container-id-3 pre{padding: 0;}#sk-container-id-3 div.sk-toggleable {background-color: white;}#sk-container-id-3 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-3 label.sk-toggleable__label-arrow:before {content: \"▸\";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-3 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-3 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-3 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-3 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-3 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-3 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: \"▾\";}#sk-container-id-3 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-3 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-3 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-3 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-3 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-3 div.sk-parallel-item::after {content: \"\";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-3 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-3 div.sk-serial::before {content: \"\";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-3 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-3 div.sk-item {position: relative;z-index: 1;}#sk-container-id-3 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-3 div.sk-item::before, #sk-container-id-3 div.sk-parallel-item::before {content: \"\";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-3 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-3 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-3 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-3 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-3 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-3 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-3 div.sk-label-container {text-align: center;}#sk-container-id-3 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-3 div.sk-text-repr-fallback {display: none;}</style><div id=\"sk-container-id-3\" class=\"sk-top-container\"><div class=\"sk-text-repr-fallback\"><pre>SVC()</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class=\"sk-container\" hidden><div class=\"sk-item\"><div class=\"sk-estimator sk-toggleable\"><input class=\"sk-toggleable__control sk-hidden--visually\" id=\"sk-estimator-id-3\" type=\"checkbox\" checked><label for=\"sk-estimator-id-3\" class=\"sk-toggleable__label sk-toggleable__label-arrow\">SVC</label><div class=\"sk-toggleable__content\"><pre>SVC()</pre></div></div></div></div></div>"
      ],
      "text/plain": [
       "SVC()"
      ]
     },
     "execution_count": 33,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Instatiate SVM\n",
    "classifier = svm.SVC()\n",
    "classifier.fit(testing_vectors_experiment, reviews_test['Label'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "id": "8c6d012a",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:38:15.076546Z",
     "iopub.status.busy": "2024-06-03T04:38:15.076090Z",
     "iopub.status.idle": "2024-06-03T04:38:15.217417Z",
     "shell.execute_reply": "2024-06-03T04:38:15.216222Z"
    },
    "papermill": {
     "duration": 0.166876,
     "end_time": "2024-06-03T04:38:15.220788",
     "exception": false,
     "start_time": "2024-06-03T04:38:15.053912",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array(['pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos',\n",
       "       'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos',\n",
       "       'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos',\n",
       "       'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos',\n",
       "       'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos',\n",
       "       'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos',\n",
       "       'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos',\n",
       "       'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos',\n",
       "       'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos',\n",
       "       'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos',\n",
       "       'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos', 'pos',\n",
       "       'pos', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg',\n",
       "       'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg',\n",
       "       'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg',\n",
       "       'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg',\n",
       "       'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg',\n",
       "       'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg',\n",
       "       'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg',\n",
       "       'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg',\n",
       "       'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg',\n",
       "       'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg',\n",
       "       'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg', 'neg',\n",
       "       'neg', 'neg'], dtype=object)"
      ]
     },
     "execution_count": 34,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Preds with test data\n",
    "predictions_experiment = classifier.predict(testing_vectors_experiment)\n",
    "predictions_experiment"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "721bf579",
   "metadata": {
    "papermill": {
     "duration": 0.01879,
     "end_time": "2024-06-03T04:38:15.259394",
     "exception": false,
     "start_time": "2024-06-03T04:38:15.240604",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Let's review the accuracy of the new model."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "id": "f2cb622e",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:38:15.299010Z",
     "iopub.status.busy": "2024-06-03T04:38:15.298586Z",
     "iopub.status.idle": "2024-06-03T04:38:15.319542Z",
     "shell.execute_reply": "2024-06-03T04:38:15.318355Z"
    },
    "papermill": {
     "duration": 0.043445,
     "end_time": "2024-06-03T04:38:15.321957",
     "exception": false,
     "start_time": "2024-06-03T04:38:15.278512",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Positives:  {'precision': 1.0, 'recall': 1.0, 'f1-score': 1.0, 'support': 100}\n",
      "Negatives:  {'precision': 1.0, 'recall': 1.0, 'f1-score': 1.0, 'support': 100}\n"
     ]
    }
   ],
   "source": [
    "report = classification_report(reviews_test['Label'], predictions_experiment, output_dict=True)\n",
    "print('Positives: ', report['pos'])\n",
    "print('Negatives: ', report['neg'])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "46857c4a",
   "metadata": {
    "papermill": {
     "duration": 0.019074,
     "end_time": "2024-06-03T04:38:15.360132",
     "exception": false,
     "start_time": "2024-06-03T04:38:15.341058",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Unsurprisingly, nothing changes because our model was previous optimized."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "76978e00",
   "metadata": {
    "papermill": {
     "duration": 0.019285,
     "end_time": "2024-06-03T04:38:15.398470",
     "exception": false,
     "start_time": "2024-06-03T04:38:15.379185",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Step 9: Experimentation"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0b273848",
   "metadata": {
    "papermill": {
     "duration": 0.018716,
     "end_time": "2024-06-03T04:38:15.436782",
     "exception": false,
     "start_time": "2024-06-03T04:38:15.418066",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Now that we have trained and tuned our model to optimization, let's explore its application to producing predictions for other text data (unrealted to our previous corpus). Our SVM model is trained on sentiment assingments for the movie reviews text data (Content), so let's apply it to another random review style. For example, this review I have for the \"Ruggable\" rug I purchased a two months ago."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "id": "b29db635",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:38:15.476564Z",
     "iopub.status.busy": "2024-06-03T04:38:15.476141Z",
     "iopub.status.idle": "2024-06-03T04:38:15.634034Z",
     "shell.execute_reply": "2024-06-03T04:38:15.632789Z"
    },
    "papermill": {
     "duration": 0.180933,
     "end_time": "2024-06-03T04:38:15.636643",
     "exception": false,
     "start_time": "2024-06-03T04:38:15.455710",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<style>#sk-container-id-4 {color: black;background-color: white;}#sk-container-id-4 pre{padding: 0;}#sk-container-id-4 div.sk-toggleable {background-color: white;}#sk-container-id-4 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-4 label.sk-toggleable__label-arrow:before {content: \"▸\";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-4 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-4 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-4 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-4 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-4 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-4 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: \"▾\";}#sk-container-id-4 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-4 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-4 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-4 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-4 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-4 div.sk-parallel-item::after {content: \"\";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-4 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-4 div.sk-serial::before {content: \"\";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-4 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-4 div.sk-item {position: relative;z-index: 1;}#sk-container-id-4 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-4 div.sk-item::before, #sk-container-id-4 div.sk-parallel-item::before {content: \"\";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-4 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-4 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-4 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-4 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-4 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-4 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-4 div.sk-label-container {text-align: center;}#sk-container-id-4 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-4 div.sk-text-repr-fallback {display: none;}</style><div id=\"sk-container-id-4\" class=\"sk-top-container\"><div class=\"sk-text-repr-fallback\"><pre>SVC()</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class=\"sk-container\" hidden><div class=\"sk-item\"><div class=\"sk-estimator sk-toggleable\"><input class=\"sk-toggleable__control sk-hidden--visually\" id=\"sk-estimator-id-4\" type=\"checkbox\" checked><label for=\"sk-estimator-id-4\" class=\"sk-toggleable__label sk-toggleable__label-arrow\">SVC</label><div class=\"sk-toggleable__content\"><pre>SVC()</pre></div></div></div></div></div>"
      ],
      "text/plain": [
       "SVC()"
      ]
     },
     "execution_count": 36,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "classifier = svm.SVC()\n",
    "classifier.fit(testing_vectors, reviews_test['Label'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "id": "4a557d6a",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:38:15.677154Z",
     "iopub.status.busy": "2024-06-03T04:38:15.676733Z",
     "iopub.status.idle": "2024-06-03T04:38:15.822653Z",
     "shell.execute_reply": "2024-06-03T04:38:15.821013Z"
    },
    "papermill": {
     "duration": 0.169226,
     "end_time": "2024-06-03T04:38:15.825293",
     "exception": false,
     "start_time": "2024-06-03T04:38:15.656067",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "vectorizer = TfidfVectorizer(min_df = 1, max_df = 1.0, sublinear_tf = True, use_idf = True)\n",
    "testing_vectors = vectorizer.fit_transform(reviews_test['Content'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "id": "483bce38",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-06-03T04:38:15.868191Z",
     "iopub.status.busy": "2024-06-03T04:38:15.867822Z",
     "iopub.status.idle": "2024-06-03T04:38:15.877169Z",
     "shell.execute_reply": "2024-06-03T04:38:15.875677Z"
    },
    "papermill": {
     "duration": 0.033739,
     "end_time": "2024-06-03T04:38:15.879771",
     "exception": false,
     "start_time": "2024-06-03T04:38:15.846032",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Review Prediction: ['neg']\n"
     ]
    }
   ],
   "source": [
    "review = \"This is a bad product, I regret purchasing the rug\"\n",
    "review_vector = vectorizer.transform([review])\n",
    "print(\"Review Prediction:\", classifier.predict(review_vector))\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1d47958b",
   "metadata": {
    "papermill": {
     "duration": 0.019111,
     "end_time": "2024-06-03T04:38:15.920351",
     "exception": false,
     "start_time": "2024-06-03T04:38:15.901240",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "The SVM totally worked! My review is negative, and the output for this prediction - although applied to a new review, related to a rug purchase - is negative (\"neg\")."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "da2e94b1",
   "metadata": {
    "papermill": {
     "duration": 0.018804,
     "end_time": "2024-06-03T04:38:15.958347",
     "exception": false,
     "start_time": "2024-06-03T04:38:15.939543",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Conclusions"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b9437585",
   "metadata": {
    "papermill": {
     "duration": 0.020077,
     "end_time": "2024-06-03T04:38:15.997800",
     "exception": false,
     "start_time": "2024-06-03T04:38:15.977723",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "In conclusion, I have learned that sentiment analyses are mutli-faceted and complex. However, python simplfies the intestity of the workflow by providing SkLearn approaches such as TfidfVectorizer, which internally executes the convultedsteps - simplfying the workflow (arguably) by at least a 100 lines of code. That is huge! It makes the sentiment analysis application very accessible and efficient. \n",
    "\n",
    "For example, we learned that Term-Frequency vectors store the *frequency* of words in a corpus, assigned as their attribute values. Meanwhile, **Term Frequency - Inverse Document Frequency (TF-IDF)** vectors store the transformed, \"normalized\" value for *each* word represented in the text data. When using SkLearn's TfidfVectorizer, this process is streamlined internally - though, this denies the Data Scientist executing the code proper code lines and opportunities for visuals for each intimate step in the transformation process. The Data Scientist needs to seek outside resources to understand these steps with intention, as demostrated briefly in this Notebook, during **Step 4: Prepreocessing**. \n",
    "\n",
    "The corpus or \"documents,\" of text, must evolve into vectors of words called \"bag of words\", which is still a foreign step when attempting to apply a linear classifer. However, once we produce our training data with assinged classifiers representing sentiment (\"pos\" or \"neg\"), it is possible to proceed with the assumed workflow for any assumed classification model. \n",
    "\n",
    "In this Notebook, we trained a Support Vector Machine (SVM) linear classifier, after applying the necessary sentiment classifier to each label of the (transformed) text data. Three important take-aways, personally, included:\n",
    "1. I was surpised to see the model immediately optimized when the default SVM settings were applied. I am curious if this was incorrectly executed, or if it is a product of the simplification of the prescribed classifier as a binary output of either postive (1) or negative (0).\n",
    "2. The SVM model worked seemlessly for text regarding an entirely irrelevant review for a rug (which I quickly mocked up for testing purposes), as it should! I was very pleased to see the accuracy appears to reflect what is exepected given the precision, f1 and recall scores.\n",
    "3. I am still cautious regarding my ability to apply these procedures, given the prepared test and training text data sets, in addition to the executable TF-IDF function in python. Perhaps it is easy to split these data, and there are no special steps required for the text (I suspect this is the case), but I would like to go through the process at to increase my confidence. Even more so, I want to finish the entire workflow provided in the \"old school\" approach for applying the TF and IDF (as demonstrated in the lecture video). I did attempt the entire workflow from scratch, but when I got hung up with errors, I bailed in order to complete the assignment.\n",
    "\n",
    "Regarding larger applications, I would love to explore outside of the context of reviews and use sentiment analyses to examine social narratives. For example, it would be interesting to use a sentiment analysis on the SCOTUS court records, which can be accessed with an API providing text for each case - this includes discussions between the judges and attorneys. It could be interesting to examine the verbiage (positive versus negative) in the discord used by the judges,and the final verdict - whether that is in favor of the plantiff or in opposition. \n"
   ]
  }
 ],
 "metadata": {
  "kaggle": {
   "accelerator": "none",
   "dataSources": [
    {
     "datasetId": 3305754,
     "sourceId": 5747460,
     "sourceType": "datasetVersion"
    }
   ],
   "dockerImageVersionId": 30474,
   "isGpuEnabled": false,
   "isInternetEnabled": true,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.10"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 35.552235,
   "end_time": "2024-06-03T04:38:16.940341",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2024-06-03T04:37:41.388106",
   "version": "2.4.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
